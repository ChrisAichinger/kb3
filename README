Slasti version 1.2
Unfortunately, Oishii was taken, so Slasti it is. It's good to be trilingual.

TODO:
 - invoke del2sla from an upload form
 - dedup URLs (show found ones at the time of entry)
 - search, aggregate in tags page - for tablets with poor ^F
 - localizations

zaitcev@yahoo.com

----- bookmarklet - XXX not parameterized; XXX login needs fixing
  <a href="javascript:location.href=
           'https://slasti.zaitcev.us/zaitcev/new' +
           '?title=' + encodeURIComponent(document.title) +
           '&href=' + encodeURIComponent(location.href)
          ">Post to Slasti</a>


================================================================
Slasti development notes

Character encoding and HTML/URL escape strategy:
As those two are pretty related, they presumably should be handled together in
the same place.
Internally, all strings are unicode.  Decoding/encoding should be done "on the
border" or very closeby. Use "from __future__ import unicode_literals" in all
new python files.

Decoding raw bytes on input:
 * ctx.path is alrady unicode, this is handled by slasti.wsgi.
 * pinput and query strings should be obtained via ctx.get_pinput_arg() and
   ctx.get_query_arg() respectively. They handle encoding issues.

The storage backend (i.e. tagbase.py) operates on unicode strings. Internally it
stores tags base64 encoded as filenames, everything else is dumped into files
encoded as utf-8.

Encoding unicode strings on output:
Can either be done in Template.substitute() (as currently) or in slasti.wsgi.
Neither is particularly tricky. What's difficult, however, is proper escaping.

The problem is that we actually want to escape strings in two different ways
for output:
 * URL encoding like urllib.quote() / urllib.quote_plus
   Noteworthy: quote() output is bytes, but contains only [A-Za-z0-9_.%/+-]
   Thus it can be turned into unicode with a unicode(quote(...)) conversion.
   Also, calling cgi.escape() on the resulting string doesn't alter it.
 * Generic HTML encoding like cgi.escape()
   _Everything_ that ends up in the HTML file has to be escaped like this,
   otherwise we're vulnerable to XSS attacks.

Solution for the output encoding problem:
 * Encode all user-generated content that ends up in URLs with
   slasti.escapeURLComponent(). This does urllib.quote_plus() and returns
   unicode.
 * The bookmark URL can't be handled like that (because quote_plus clobbers the
   :// portion of the URL). Use slasti.escapeURL(). The resulting string is
   unicode and is safe to use within attributes.
 * Everything else should end up in jsondict as unescaped unicode, escaping and
   encoding is handled in the templating engine.
 * Template().substitute() returns bytes. Don't mess with that, just return it
   to the wsgi server.
